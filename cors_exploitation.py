from ten import *
import argparse
import os
from colorama import Fore, Style, init
from collections import defaultdict
from utils.helpers import (extract_domain,load_endpoints,save_findings_to_file, get_origins_to_test,check_url_reachable)
from utils.poc_generator import generate_poc_interactive
from utils.requests_utils import send_cors_request
from utils.validation_utils import is_valid_originUrl
from utils.parsing_utils import (analyze_origin_behavior,check_reflected_origin,check_null_origin,check_parser_confusion,check_blind_subdomain_trust,check_wildcard_plus_credentials)

def intro():
    logo = """
░░      ░░░      ░░       ░░░      ░░░░░░░        ░  ░░░░  ░       ░░  ░░░░░░░░      ░░        ░        ░░      ░░        ░        ░░      ░░   ░░░  ░
▒  ▒▒▒▒  ▒  ▒▒▒▒  ▒  ▒▒▒▒  ▒  ▒▒▒▒▒▒▒▒▒▒▒▒  ▒▒▒▒▒▒▒▒  ▒▒  ▒▒  ▒▒▒▒  ▒  ▒▒▒▒▒▒▒  ▒▒▒▒  ▒▒▒▒  ▒▒▒▒▒▒▒  ▒▒▒▒  ▒▒▒▒  ▒▒▒▒  ▒▒▒▒▒▒▒  ▒▒▒▒  ▒▒▒▒  ▒    ▒▒  ▒
▓  ▓▓▓▓▓▓▓  ▓▓▓▓  ▓       ▓▓▓      ▓▓▓▓▓▓▓      ▓▓▓▓▓    ▓▓▓       ▓▓  ▓▓▓▓▓▓▓  ▓▓▓▓  ▓▓▓▓  ▓▓▓▓▓▓▓  ▓▓▓▓  ▓▓▓▓  ▓▓▓▓  ▓▓▓▓▓▓▓  ▓▓▓▓  ▓▓▓▓  ▓  ▓  ▓  ▓
█  ████  █  ████  █  ███  ████████  ██████  ████████  ██  ██  ███████  ███████  ████  ████  ███████  ████        ████  ███████  ████  ████  █  ██    █
██      ███      ██  ████  ██      ███████        █  ████  █  ███████        ██      ██        ████  ████  ████  ████  ████        ██      ██  ███   █
                                                                                                                                                      
CORS Misconfiguration Exploitation Script
Made By Yair Shachar
v1.0

"""
    print(Fore.RED + logo+ Fore.WHITE)


def args_parser():
    parser = argparse.ArgumentParser(description="Cors explotation tool")
    parser.add_argument('-u','--url', help="The target URL")
    parser.add_argument('-o','--origin',required=True, help="Origin to test")
    parser.add_argument('-H','--header', action='append', metavar='"Header: value"', help="Custom header to add to requests. Can be used multiple times.")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-e','--endpoint', metavar='/endpoint', help="Single edpoint to test.")
    group.add_argument('-E','--endpoints', help="File containing endpoints to test.")
    parser.add_argument('-p','--proxy', metavar='PROXY_URL', help="Proxy to use for all requests, e.g., http://127.0.0.1:8080")
    parser.add_argument('--verify-ssl', action='store_false', default=True, help="Disable SSL certificate verification")
    parser.add_argument('--poc', action='store_true', help="Generate HTML PoC files for exploitable targets")
    parser.add_argument('--extended', action='store_true', help="Include additional advanced origins (e.g. file://, extensions, localhost)")
    args = parser.parse_args()
    if not args.url :
        msg_failure("You must provide --url | -u.")
        exit(1)
    if not args.endpoint and not args.endpoints:
        msg_failure("You must provide either --endpoint | -e or --endpoints | -E.")
        exit(1)
    if args.endpoints and not os.path.isfile(args.endpoints):
        msg_failure("Input file " + args.endpoints + " not exist.")
        exit(1)
    if not is_valid_originUrl(args.origin):
        msg_warning(f"The supplied origin '{args.origin}' appears to be invalid (scheme://host[:port]). You can continue, but the server might not process it properly.")
    if args.url.endswith('/'):
        args.url = args.url.rstrip('/')
    if not is_valid_originUrl(args.url):
        msg_failure(f"Url {args.url} is not formatted well")
        exit(1)
    return args



def main():
    intro()
    try:
        args = args_parser()
        proxies = {"http": args.proxy, "https": args.proxy} if args.proxy else None
        target = args.url
        if not check_url_reachable(target, proxies=proxies, verify=args.verify_ssl):
            exit(1)
        endpoints = load_endpoints(args.endpoint, args.endpoints)
        all_findings = []
        if not endpoints:
            msg_failure("No valid endpoints found")
            exit(1)
        origins = get_origins_to_test(args.origin, target, args.extended)
        for endpoint in endpoints:
            try:
                full_results = []
                full_url = target + endpoint
                print("\n\n")
                msg_success(f"Testing endpoint: {endpoint}")
                origins = get_origins_to_test(args.origin, target, args.extended)
                for origin in origins:
                    try:
                        status, resp_headers, body = send_cors_request(url=full_url,origin=origin, headers=args.header, proxies=proxies, verify_ssl=args.verify_ssl)
                        result = {"origin": origin, "status": status, "headers": dict(resp_headers), "body": body}
                        full_results.append(result)
                    except Exception as e:
                        msg_warning(f"Request failed for origin {origin}: {e}")

                msg_success(f"Finished collecting data for {endpoint}, now parsing")

            except Exception as e:
                msg_failure(f"Failed to test endpoint {endpoint}: {e}")
                break
            # Start analayze
            findings = analyze_origin_behavior(full_results, endpoint)

            if findings:
                all_findings.extend(findings)
                grouped = defaultdict(list)
                for f in findings:
                    key = (f["vuln"], f["endpoint"])
                    grouped[key].append(f["evidence"]["origin"])

                for (vuln, endpoint), origins in grouped.items():
                    msg_success(Fore.RED + f"{vuln} detected at {endpoint}")
                    for o in origins:
                        print(Fore.WHITE +f"    └─ Origin: {o}"+Fore.WHITE)
            else:
                msg_warning(f"Didnt find any finding for endpoint {endpoint}.")
        if all_findings:
            save_findings_to_file(all_findings)
            pass
        if args.poc:
            generate_poc_interactive(target)



    except Exception as e:
        msg_failure(f"Fatal error: {e}")
        exit(1)


if __name__ == '__main__':
    main()